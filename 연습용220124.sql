-- 테이블 만들기
CREATE TABLE TEST_SELF(
    TEST_ID VARCHAR2(20),
    TEST_PWD VARCHAR2(30),
    TEST_NAME VARCHAR2(30)
);

-- 만들어진 테이블 확인
SELECT
       T.*
  FROM TEST_SELF T ;
  
-- 컬럼에 주석달기
COMMENT ON COLUMN TEST_SELF.TEST_ID IS '회원아이디';
COMMENT ON COLUMN TEST_SELF.TEST_PWD IS '비밀번호';
COMMENT ON COLUMN TEST_SELF.TEST_NAME IS '회원이름';

--유저가 가지고 있는 테이블 전체 조회
SELECT
       UT.*
  FROM USER_TABLES UT;
  
-- 
SELECT
       UTC.*
  FROM USER_TAB_COLUMNS UTC
 WHERE UTC.TABLE_NAME = 'TEST_SELF';

-- 회원 가입용 테이블 생성(USER_SELF)
-- 컬럼명 : USER_NO(회원이름)
--         USER_ID(아이디) -- 중복 금지, NULL값 허용 안함
--         USER_PWD(비밀번호) -- NULL값 허용 안함
--         PNO(주민번호)-- 중복 금지, NULL값 허용 안함
--         GENDER(성별) -- '남' 또는 '여'로 입력
--         PHONE(연락처)
--         ADDRESS(주소)
--         STATUS(탈퇴여부) -- NOT NULL, 'Y' 혹은 'N'으로 입력
-- 각 제약조건 이름 부여
-- 5명 이상 회원정보 INSERT
-- 각 컬럼별로 코멘트 생성

CREATE TABLE USER_SELF(
    USER_NO VARCHAR2(20) ,
    USER_ID VARCHAR2(20) CONSTRAINT NN_USER_ID NOT NULL,
    USER_PWD VARCHAR2(30) CONSTRAINT NN_USER_PWD NOT NULL,
    PNO VARCHAR2(30) CONSTRAINT NN_PNO NOT NULL,
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(20),
    ADDRESS VARCHAR2(50),
    STATUS VARCHAR2(10) CONSTRAINT NN_STATUS NOT NULL,
    CONSTRAINT UK_USER_ID UNIQUE (USER_ID),
    CONSTRAINT UK_PNO UNIQUE (PNO),
    CONSTRAINT CK_GENDER CHECK (GENDER IN ('남','여')),
    CONSTRAINT CK_STATUS CHECK (STATUS IN ('Y' , 'N'))
);

COMMENT ON COLUMN USER_SELF.USER_NO IS '회원이름' ;
COMMENT ON COLUMN USER_SELF.USER_ID IS '아이디';
COMMENT ON COLUMN USER_SELF.USER_PWD IS '비밀번호';
COMMENT ON COLUMN USER_SELF.PNO IS '주민번호';
COMMENT ON COLUMN USER_SELF.GENDER IS '성별';
COMMENT ON COLUMN USER_SELF.PHONE IS '연락처';
COMMENT ON COLUMN USER_SELF.ADDRESS IS '주소';
COMMENT ON COLUMN USER_SELF.STATUS IS '탈퇴여부';

INSERT 
  INTO USER_SELF
(
  USER_NO, USER_ID, USER_PWD, PNO, GENDER, 
  PHONE, ADDRESS, STATUS
)
VALUES
(
  '1', 'USER01', 'USER01', '950604-1052369', '여',
  '010-1234-5678', '서울특별시 마포구 상암동', 'N'
);

INSERT 
  INTO USER_SELF
(
  USER_NO, USER_ID, USER_PWD, PNO, GENDER, 
  PHONE, ADDRESS, STATUS
)
VALUES
(
  '2', 'USER02', 'USER02', '910125-1045859', '남',
  '010-5678-5678', '서울특별시 마포구 상암동', 'N'
);

INSERT 
  INTO USER_SELF
(
  USER_NO, USER_ID, USER_PWD, PNO, GENDER, 
  PHONE, ADDRESS, STATUS
)
VALUES
(
  '3', 'USER03', 'USER03', '030604-4052369', '여',
  '010-9999-5678', '서울특별시 강남구 역삼동', 'N'
);

INSERT 
  INTO USER_SELF
(
  USER_NO, USER_ID, USER_PWD, PNO, GENDER, 
  PHONE, ADDRESS, STATUS
)
VALUES
(
  '4', 'USER04', 'USER04', '930526-1055369', '남',
  '010-1234-8521', '서울특별시 서초구 서초동', 'Y'
);

INSERT 
  INTO USER_SELF
(
  USER_NO, USER_ID, USER_PWD, PNO, GENDER, 
  PHONE, ADDRESS, STATUS
)
VALUES
(
  '5', 'USER05', 'USER05', '900415-2052259', '여',
  '010-8578-5678', '서울특별시 서대문구 신촌동', 'N'
);

--만들어진 USER_SELF 확인
SELECT
       US.*
  FROM USER_SELF US;
  
CREATE TABLE TEST_PRIMARYKEY(
    USER_NO NUMBER CONSTRAINT PK_USER_NO_TEST PRIMARY KEY,
    USER_ID VARCHAR2(20) UNIQUE,
    USER_PWD VARCHAR2(20) NOT NULL,
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10) CHECK(GENDER IN('여', '남')),
    PHONE VARCHAR2(20),
    EMAIL VARCHAR2(50)
);

INSERT
  INTO TEST_PRIMARYKEY
(
  USER_NO, USER_ID, USER_PWD, USER_NAME,
  GENDER, PHONE, EMAIL
)
VALUES
(
  1, 'USER01', 'PASS01', '임연유',
  '남', '010-1234-5678', 'yoo0112@greedy.com'
);

-- PRIMARY KEY 제약을 걸어둔 USER_NO가 중복될 경우 무결성 제약 조건 위배 확인 ==UNIQE 해야함
INSERT
  INTO TEST_PRIMARYKEY
(
  USER_NO, USER_ID, USER_PWD, USER_NAME,
  GENDER, PHONE, EMAIL
)
VALUES
(
  1, 'USER02', 'PASS02', '김뫄뫄',
  '여', '010-7777-5678', 'mm0112@greedy.com'
);

-- PRIMARY KEY 제약을 걸어둔 USER_NO가 NULL값이 될 경우 불가 == NOT NULL
INSERT
  INTO TEST_PRIMARYKEY
(
  USER_NO, USER_ID, USER_PWD, USER_NAME,
  GENDER, PHONE, EMAIL
)
VALUES
(
  NULL, 'USER02', 'PASS02', '김뫄뫄',
  '여', '010-7777-5678', 'mm0112@greedy.com'
);

-- CONSTRAINT NAME 이 PK_USER_NO_TEST 인 제약 조회
SELECT
       UC.TABLE_NAME
     , UCC.COLUMN_NAME
     , UC.CONSTRAINT_NAME
     , UC.CONSTRAINT_TYPE
  FROM USER_CONSTRAINTS UC
  JOIN USER_CONS_COLUMNS UCC ON(UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME )
 WHERE UC.CONSTRAINT_NAME = 'PK_USER_NO_TEST';
 
-- 테이블 레벨에서 PK 설정 (복합키로 설정)
CREATE TABLE TEST_PRIMARYKEY2
(
    USER_NO NUMBER ,
    USER_ID VARCHAR2(20) UNIQUE,
    USER_PWD VARCHAR2(20) NOT NULL,
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10) CHECK(GENDER IN('여', '남')),
    PHONE VARCHAR2(20),
    EMAIL VARCHAR2(50),
    CONSTRAINT PK_USER_NO_TEST2 PRIMARY KEY (USER_NO, USER_ID)
);

INSERT
  INTO TEST_PRIMARYKEY2
(
  USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER,
  PHONE, EMAIL
)
VALUES
(
  1, 'USER01', 'PASS01', '임연유' , '남',
  '010-1234-5678', 'yoo0212@greddy.com'
);

-- 제약을 묶음으로 지정했기 때문에 USER_NO 한개만 중복은 사용가능
INSERT
  INTO TEST_PRIMARYKEY2
(
  USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER,
  PHONE, EMAIL
)
VALUES
(
  1, 'USER02', 'PASS02', '박룰루' , '여',
  '010-1234-5645', 'RURU0212@greddy.com'
);

SELECT
       TP2.*
  FROM TEST_PRIMARYKEY2 TP2;
  
--외래키(FOREIGN KEY)
CREATE TABLE TEST_GRADE(
    GRADE_CODE NUMBER PRIMARY KEY,
    GRADE_NAME VARCHAR2(30) NOT NULL
);

INSERT
  INTO TEST_GRADE
(
  GRADE_CODE, GRADE_NAME
)
VALUES
(
  10, '일반회원'
);

INSERT
  INTO TEST_GRADE
(
  GRADE_CODE, GRADE_NAME
)
VALUES
(
  20, '우수회원'
);

INSERT
  INTO TEST_GRADE
(
  GRADE_CODE, GRADE_NAME
)
VALUES
(
  30, '특별회원'
);

SELECT
       TG.*
  FROM TEST_GRADE TG;
  
CREATE TABLE TEST_FORIEGNKEY(
    USER_NO NUMBER PRIMARY KEY,
    USER_ID VARCHAR2(20) UNIQUE,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50),
    GRADE_CODE NUMBER,
    CONSTRAINT FK_GRADE_CODE_TEST FOREIGN KEY(GRADE_CODE) REFERENCES TEST_GRADE(GRADE_CODE)
);

--TEST_FORIEGNKEY 회원정보 입력
INSERT
  INTO TEST_FORIEGNKEY
(
  USER_NO, USER_ID, USER_PWD, USER_NAME,
  GENDER, PHONE, EMAIL, GRADE_CODE
)
VALUES
( 
  1, 'USER1', 'TEST1', '홍길동',
  '남', '010-1111-2222', 'HONG@GRRDY.COM', 10
  );
  
INSERT
  INTO TEST_FORIEGNKEY
(
  USER_NO, USER_ID, USER_PWD, USER_NAME,
  GENDER, PHONE, EMAIL, GRADE_CODE
)
VALUES
( 
  2, 'USER2', 'TEST2', '유관순',
  '여', '010-2222-3333', 'YOO@GRRDY.COM', 20
  );
  
-- 외래키 NULL값 가능  
INSERT
  INTO TEST_FORIEGNKEY
(
  USER_NO, USER_ID, USER_PWD, USER_NAME,
  GENDER, PHONE, EMAIL, GRADE_CODE
)
VALUES
( 
  3, 'USER3', 'TEST3', '신사임당',
  '여', '010-5555-6666', 'SHIN@GRRDY.COM', NULL
  );
  
-- 외래키 지정된 값 외 불가능  // 부모 키가 없다는 무결성 제약조건 위배
INSERT
  INTO TEST_FORIEGNKEY
(
  USER_NO, USER_ID, USER_PWD, USER_NAME,
  GENDER, PHONE, EMAIL, GRADE_CODE
)
VALUES
( 
  4, 'USER4', 'TEST4', '윤봉길',
  '남', '010-7777-8888', 'YOON@GRRDY.COM', 50
  );
  
SELECT
       TF.*
  FROM TEST_FORIEGNKEY TF;

-- FOREIGN KEY로 지정 된 컬럼에서 사용되고 있는 값일 경우
-- 제공하는 컬럼의 값은 삭제하지 못한다.  
DELETE
  FROM TEST_GRADE
 WHERE GRADE_CODE = 10;
 
COMMIT;

DELETE 
  FROM TEST_GRADE
 WHERE GRADE_CODE = 30;

SELECT
       TG.*
  FROM TEST_GRADE TG;
  
ROLLBACK;

CREATE TABLE TEST_GRADE2(
    GRADE_CODE NUMBER PRIMARY KEY,
    GRADE_NAME VARCHAR2(30) NOT NULL
);

INSERT
  INTO TEST_GRADE2
( 
  GRADE_CODE, GRADE_NAME
)
VALUES
(
  10, '일반회원'
);

INSERT
  INTO TEST_GRADE2
( 
  GRADE_CODE, GRADE_NAME
)
VALUES
(
  20, '우수회원'
);

INSERT
  INTO TEST_GRADE2
( 
  GRADE_CODE, GRADE_NAME
)
VALUES
(
  30, '특별회원'
);

CREATE TABLE TEST_FORIEGNKEY2(
    USER_NO NUMBER PRIMARY KEY,
    USER_ID VARCHAR2(20) UNIQUE,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50),
    GRADE_CODE NUMBER,
    CONSTRAINT FK_GRADE_CODE_TEST2 FOREIGN KEY(GRADE_CODE) REFERENCES TEST_GRADE2(GRADE_CODE) ON DELETE SET NULL
);

--TEST_FORIEGNKEY2 회원정보 입력
INSERT
  INTO TEST_FORIEGNKEY2
(
  USER_NO, USER_ID, USER_PWD, USER_NAME,
  GENDER, PHONE, EMAIL, GRADE_CODE
)
VALUES
( 
  1, 'USER1', 'TEST1', '홍길동',
  '남', '010-1111-2222', 'HONG@GRRDY.COM', 10
  );
  
INSERT
  INTO TEST_FORIEGNKEY2
(
  USER_NO, USER_ID, USER_PWD, USER_NAME,
  GENDER, PHONE, EMAIL, GRADE_CODE
)
VALUES
( 
  2, 'USER2', 'TEST2', '유관순',
  '여', '010-2222-3333', 'YOO@GRRDY.COM', 20
  );
  
-- 외래키 NULL값 가능  
INSERT
  INTO TEST_FORIEGNKEY2
(
  USER_NO, USER_ID, USER_PWD, USER_NAME,
  GENDER, PHONE, EMAIL, GRADE_CODE
)
VALUES
( 
  3, 'USER3', 'TEST3', '신사임당',
  '여', '010-5555-6666', 'SHIN@GRRDY.COM', NULL
  );
  
SELECT
      TF.*
  FROM TEST_FORIEGNKEY2 TF;
  
COMMIT;

DELETE
  FROM TEST_GRADE2
 WHERE GRADE_CODE = 10;
 
ROLLBACK;

-- ON DELETE CASCADE : 부모 키 삭제 시 자식 키를 가진 행도 함께 삭제
CREATE TABLE TEST_GRADE3(
    GRADE_CODE NUMBER PRIMARY KEY,
    GRADE_NAME VARCHAR2(30) NOT NULL
);

INSERT
  INTO TEST_GRADE3
( 
  GRADE_CODE, GRADE_NAME
)
VALUES
(
  10, '일반회원'
);

INSERT
  INTO TEST_GRADE3
( 
  GRADE_CODE, GRADE_NAME
)
VALUES
(
  20, '우수회원'
);

INSERT
  INTO TEST_GRADE3
( 
  GRADE_CODE, GRADE_NAME
)
VALUES
(
  30, '특별회원'
);

CREATE TABLE TEST_FORIEGNKEY3(
    USER_NO NUMBER PRIMARY KEY,
    USER_ID VARCHAR2(20) UNIQUE,
    USER_PWD VARCHAR2(30) NOT NULL,
    USER_NAME VARCHAR2(30),
    GENDER VARCHAR2(10),
    PHONE VARCHAR2(30),
    EMAIL VARCHAR2(50),
    GRADE_CODE NUMBER,
    CONSTRAINT FK_GRADE_CODE_TEST3 FOREIGN KEY(GRADE_CODE) REFERENCES TEST_GRADE3(GRADE_CODE) ON DELETE CASCADE
);


--TEST_FORIEGNKEY3 회원정보 입력
INSERT
  INTO TEST_FORIEGNKEY3
(
  USER_NO, USER_ID, USER_PWD, USER_NAME,
  GENDER, PHONE, EMAIL, GRADE_CODE
)
VALUES
( 
  1, 'USER1', 'TEST1', '홍길동',
  '남', '010-1111-2222', 'HONG@GRRDY.COM', 10
  );
  
INSERT
  INTO TEST_FORIEGNKEY3
(
  USER_NO, USER_ID, USER_PWD, USER_NAME,
  GENDER, PHONE, EMAIL, GRADE_CODE
)
VALUES
( 
  2, 'USER2', 'TEST2', '유관순',
  '여', '010-2222-3333', 'YOO@GRRDY.COM', 20
  );
  
-- 외래키 NULL값 가능  
INSERT
  INTO TEST_FORIEGNKEY3
(
  USER_NO, USER_ID, USER_PWD, USER_NAME,
  GENDER, PHONE, EMAIL, GRADE_CODE
)
VALUES
( 
  3, 'USER3', 'TEST3', '신사임당',
  '여', '010-5555-6666', 'SHIN@GRRDY.COM', NULL
  );
  
DELETE
  FROM TEST_GRADE3
 WHERE GRADE_CODE = 10;
 
SELECT
       TF.*
  FROM TEST_FORIEGNKEY3 TF;
  
-- 실습
-- EMPLOYEE 테이블의 DEPT_CODE에 외래키 제약조건 추가
-- 참조 테이블은 DEPARTMENT, 참조컬럼은 DEPARTMENT의 기본키 (PK설정되어있으면 컬럼명 생략 가능)
ALTER TABLE EMPLOYEE
ADD FOREIGN KEY (DEPT_CODE) REFERENCES DEPARTMENT (DEPT_ID);

-- DEPARTMENT 테이블의 LOCATION_ID에 외래키 제약조건 추가
-- 참조 테이블은 LOCATION, 참조 컬럼은 LOCATION의 기본키
ALTER TABLE DEPARTMENT 
ADD FOREIGN KEY (LOCATION_ID) REFERENCES LOATION (LOCAL_CODE);

-- EMPLOYEE 테이블의 JOB_CODE에 외래키 제약조건 추가
-- 참조 테이블은 JOB 테이블, 참조 컬럼은 JOB테이블의 기본키
ALTER TABLE EMPLOYEE ADD FOREIGN KEY (JOB_CODE) REFERENCES JOB (JOB_CODE);

-- EMPLOYEE 테이블의 SAL_LEVEL에 외래키 제약조건 추가
-- 참조테이블은 SAL_GRADE테이블, 참조 컬럼은 SAL_GRADE테이블 기본키
ALTER TABLE EMPLOYEE ADD FOREIGN KEY (SAL_LEVEL) REFERENCES SAL_GRADE (SAL_LEVEL);

-- EMPLOYEE테이블의 ENT_YN컬럼에 CHECK제약조건 추가('Y','N')
-- 단, 대 소문자를 구분하기 때문에 대문자로 설정
ALTER TABLE EMPLOYEE ADD CHECK (ENT_YN IN('Y','N'));

-- EMPLOYEE테이블의 SALARY 컬럼에 CHECK제약조건 추가(양수)
ALTER TABLE EMPLOYEE ADD CHECK((SALARY) > 0);

-- EMPLOYEE테이블의 EMP_NO컬럼에 UNIQUE 제약조건 추가
ALTER TABLE EMPLOYEE ADD UNIQUE (EMP_NO);



